[
  {
    "id": 1,
    "title": "Core Java Basics",
    "difficulty": "basic",
    "topics": [
      {
        "name": "Introduction to Java",
        "subTopics": [
          { "name": "History of Java" },
          { "name": "Features of Java (Platform Independent, OOP, etc.)" },
          { "name": "JDK, JRE, JVM Architecture" },
          { "name": "Java compilation process" },
          { "name": "Bytecode and Platform Independence" },
          { "name": "Java Editions (SE, EE, ME)" },
          { "name": "Path and Classpath (Environment Variables)" },
          { "name": "First Java Program structure and main method" },
          { "name": "Java Keywords and Identifiers" },
          { "name": "Comments in Java (Single-line, Multi-line, Documentation)" },
          { "name": "Java vs C++ comparison" },
          { "name": "Java is Pass-by-Value" }
        ]
      },
      {
        "name": "Data Types & Variables",
        "subTopics": [
          { "name": "Primitive data types" },
          { "name": "Reference types" },
          { "name": "Type casting and conversion" },
          { "name": "Variables (local, instance, static)" }
        ]
      },
      {
        "name": "Operators & Control Statements",
        "subTopics": [
          { "name": "Arithmetic, Logical, Relational operators" },
          { "name": "If-else, switch statements" },
          { "name": "Loops (for, while, do-while, enhanced for)" },
          { "name": "Break, continue, return statements" }
        ]
      },
      {
        "name": "Arrays & Basic I/O",
        "subTopics": [
          { "name": "Single and multidimensional arrays" },
          { "name": "Array manipulation" },
          { "name": "Jagged arrays" },
          { "name": "Scanner class and Console I/O" }
        ]
      }
    ]
  },
  {
    "id": 2,
    "title": "Object-Oriented Programming (OOP)",
    "difficulty": "basic",
    "topics": [
      {
        "name": "Classes and Objects",
        "subTopics": [
          { "name": "Class definition and object creation" },
          { "name": "Constructors (default, parameterized, copy)" },
          { "name": "Constructor overloading" },
          { "name": "this keyword" },
          { "name": "Object Initialization Order" }
        ]
      },
      {
        "name": "Encapsulation",
        "subTopics": [
          { "name": "Access modifiers (private, public, protected, default)" },
          { "name": "Getters and Setters" },
          { "name": "Data hiding" }
        ]
      },
      {
        "name": "Inheritance & Composition",
        "subTopics": [
          { "name": "Types of inheritance" },
          { "name": "super keyword" },
          { "name": "Method overriding" },
          { "name": "final keyword" },
          { "name": "IS-A vs HAS-A relationship" }
        ]
      },
      {
        "name": "Polymorphism",
        "subTopics": [
          { "name": "Compile-time (Method Overloading)" },
          { "name": "Runtime (Method Overriding)" },
          { "name": "Dynamic method dispatch" }
        ]
      },
      {
        "name": "Abstraction",
        "subTopics": [
          { "name": "Abstract classes and methods" },
          { "name": "Interfaces" },
          { "name": "Multiple inheritance using interfaces" },
          { "name": "Marker interfaces" }
        ]
      }
    ]
  },
  {
    "id": 3,
    "title": "Advanced OOP & Java Language Features",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Static keyword",
        "subTopics": [
          { "name": "Static variables and methods" },
          { "name": "Static blocks" },
          { "name": "Static nested classes" }
        ]
      },
      {
        "name": "Inner Classes",
        "subTopics": [
          { "name": "Member inner class" },
          { "name": "Static nested class" },
          { "name": "Local inner class" },
          { "name": "Anonymous inner class" }
        ]
      },
      {
        "name": "Packages",
        "subTopics": [
          { "name": "Creating and using packages" },
          { "name": "Import statements" },
          { "name": "Access protection" }
        ]
      },
      {
        "name": "Object Class Methods",
        "subTopics": [
          { "name": "equals() and hashCode() contract" },
          { "name": "toString()" },
          { "name": "clone()" },
          { "name": "finalize()" }
        ]
      }
    ]
  },
  {
    "id": 4,
    "title": "Exception Handling",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Core Exception Handling",
        "subTopics": [
          { "name": "Fundamentals" },
          { "name": "Exception Hierarchy" },
          { "name": "Checked vs Unchecked Exceptions" },
          { "name": "try–catch–finally blocks" },
          { "name": "Multi-Catch and try-with-resources" },
          { "name": "throw vs throws keyword" },
          { "name": "Custom Exceptions" },
          { "name": "Exception Propagation" },
          { "name": "Exception Chaining" },
          { "name": "Best Practices for Core Java Exception Handling" }
        ]
      }
    ]
  },
  {
    "id": 5,
    "title": "Collections Framework",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Collection Interfaces",
        "subTopics": [
          { "name": "Collection, List, Set, Queue, Map" },
          { "name": "Iterator, ListIterator, and Spliterator" }
        ]
      },
      {
        "name": "Implementations",
        "subTopics": [
          { "name": "ArrayList, LinkedList, Vector, Stack" },
          { "name": "HashSet, LinkedHashSet, TreeSet" },
          { "name": "HashMap, LinkedHashMap, TreeMap" },
          { "name": "Hashtable and ConcurrentHashMap" },
          { "name": "PriorityQueue and ArrayDeque" }
        ]
      },
      {
        "name": "Sorting and Utility",
        "subTopics": [
          { "name": "Comparable vs Comparator" },
          { "name": "Collections and Arrays utility classes" }
        ]
      }
    ]
  },
  {
    "id": 6,
    "title": "Generics",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Generic Classes and Methods" },
      { "name": "Bounded Type Parameters" },
      { "name": "Wildcards (?, extends, super)" },
      { "name": "PECS Principle" },
      { "name": "Type Erasure" }
    ]
  },
  {
    "id": 7,
    "title": "Multithreading & Concurrency",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Thread Basics",
        "subTopics": [
          { "name": "Thread class vs Runnable interface" },
          { "name": "Thread lifecycle" },
          { "name": "sleep, join, yield, interrupt" }
        ]
      },
      {
        "name": "Synchronization",
        "subTopics": [
          { "name": "synchronized keyword (blocks/methods)" },
          { "name": "Locking: Object level vs Class level" },
          { "name": "volatile keyword" },
          { "name": "Deadlock, Livelock, and Starvation" }
        ]
      },
      {
        "name": "Inter-thread Communication",
        "subTopics": [
          { "name": "wait, notify, and notifyAll" },
          { "name": "Producer-Consumer problem" }
        ]
      },
      {
        "name": "Concurrency Utilities",
        "subTopics": [
          { "name": "Executor Framework and Thread Pools" },
          { "name": "Callable and Future" },
          { "name": "CompletableFuture" },
          { "name": "Locks (ReentrantLock, ReadWriteLock)" },
          { "name": "Atomic variables" },
          { "name": "CountDownLatch and CyclicBarrier" }
        ]
      }
    ]
  },
  {
    "id": 8,
    "title": "Java Version-wise Features",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Java 8 Features",
        "subTopics": [
          { "name": "Lambda Expressions" },
          { "name": "Functional Interfaces" },
          { "name": "Stream API" },
          { "name": "Optional Class" },
          { "name": "Default and Static methods in Interfaces" },
          { "name": "Date and Time API (java.time)" }
        ]
      },
      {
        "name": "Java 9 to 11 Features",
        "subTopics": [
          { "name": "Module System (JPMS)" },
          { "name": "Private methods in Interfaces" },
          { "name": "JShell" },
          { "name": "var keyword (Local Variable Type Inference)" },
          { "name": "HTTP Client API" }
        ]
      },
      {
        "name": "Java 12 to 17 Features (LTS)",
        "subTopics": [
          { "name": "Switch Expressions" },
          { "name": "Text Blocks" },
          { "name": "Records" },
          { "name": "Sealed Classes" },
          { "name": "Pattern Matching for instanceof" }
        ]
      },
      {
        "name": "Java 21 Features (LTS)",
        "subTopics": [
          { "name": "Virtual Threads (Project Loom)" },
          { "name": "Sequenced Collections" },
          { "name": "Record Patterns" },
          { "name": "Pattern Matching for Switch" }
        ]
      }
    ]
  },
  {
    "id": 9,
    "title": "String Handling",
    "difficulty": "basic",
    "topics": [
      { "name": "String immutability and String Pool" },
      { "name": "String vs StringBuilder vs StringBuffer" },
      { "name": "Common String methods" },
      { "name": "String formatting and manipulation" }
    ]
  },
  {
    "id": 10,
    "title": "Regular Expressions (Regex)",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Pattern and Matcher classes" },
      { "name": "Regex metacharacters and quantifiers" },
      { "name": "Groups and capturing" },
      { "name": "Common regex patterns for validation" }
    ]
  },
  {
    "id": 11,
    "title": "File I/O & Serialization",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Byte Streams vs Character Streams" },
      { "name": "BufferedReader and BufferedWriter" },
      { "name": "Java NIO (Path, Files, Channels)" },
      { "name": "Serialization and Deserialization (transient, serialVersionUID)" },
      { "name": "Externalizable interface" }
    ]
  },
  {
    "id": 12,
    "title": "Networking in Java",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Socket Programming (TCP/UDP)" },
      { "name": "URL and URLConnection" },
      { "name": "HttpURLConnection" },
      { "name": "InetAddress class" }
    ]
  },
  {
    "id": 13,
    "title": "JDBC (Database Connectivity)",
    "difficulty": "intermediate",
    "topics": [
      { "name": "JDBC Architecture and Drivers" },
      { "name": "Statement vs PreparedStatement vs CallableStatement" },
      { "name": "ResultSet and Transaction Management" },
      { "name": "Connection Pooling concepts" }
    ]
  },
  {
    "id": 14,
    "title": "JVM Internals & Memory Management",
    "difficulty": "advanced",
    "topics": [
      { "name": "JVM Architecture: ClassLoader, Runtime Data Areas, Execution Engine" },
      { "name": "Heap vs Stack Memory" },
      { "name": "Garbage Collection Algorithms (G1, ZGC, etc.)" },
      { "name": "JIT Compiler and Memory Leaks" },
      { "name": "Memory Model and happens-before relationship" },
      { "name": "Reference Types (Strong, Weak, Soft, Phantom)" }
    ]
  },
  {
    "id": 15,
    "title": "Advanced Java Concepts",
    "difficulty": "advanced",
    "topics": [
      { "name": "Cloning (Shallow vs Deep)" },
      { "name": "Immutable Objects creation" },
      { "name": "Java Native Interface (JNI)" },
      { "name": "Java Beans" },
      { "name": "RMI (Remote Method Invocation)" },
      { "name": "Java Security Manager" }
    ]
  },
  {
    "id": 16,
    "title": "Miscellaneous Core Topics",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Reflection API" },
      { "name": "Annotations (Built-in and Custom)" },
      { "name": "Enums" },
      { "name": "Wrapper Classes and Autoboxing/Unboxing" },
      { "name": "Internationalization (i18n) and Localization" },
      { "name": "JavaDoc and Code Documentation" }
    ]
  },
  {
    "id": 17,
    "title": "Core Java Design Principles",
    "difficulty": "advanced",
    "topics": [
      { "name": "SOLID Principles" },
      { "name": "Creational Design Patterns (Singleton, Factory, Builder)" },
      { "name": "Structural Design Patterns (Adapter, Proxy, Decorator)" },
      { "name": "Behavioral Design Patterns (Observer, Strategy)" }
    ]
  },
  {
    "id": 18,
    "title": "Best Practices & Code Quality",
    "difficulty": "intermediate",
    "topics": [
      { "name": "Clean Code principles" },
      { "name": "Code smells and refactoring" },
      { "name": "Exception handling best practices" },
      { "name": "Naming conventions and coding standards" },
      { "name": "Performance optimization techniques" },
      { "name": "Unit Testing with JUnit and Mockito" }
    ]
  }
]