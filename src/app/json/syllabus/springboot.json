[
  {
    "id": 1,
    "title": "Spring Boot Fundamentals",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Spring Boot vs Spring",
        "subTopics": [
          { "name": "Why Spring Boot was introduced" },
          { "name": "Problems it solves" },
          { "name": "Spring vs Spring Boot (VERY COMMON)" }
        ]
      },
      {
        "name": "@SpringBootApplication",
        "subTopics": [
          { "name": "What it is internally" },
          { "name": "Combination of: @Configuration, @ComponentScan, @EnableAutoConfiguration" },
          { "name": "Why it should be placed in root package" }
        ]
      },
      {
        "name": "Starters",
        "subTopics": [
          { "name": "What are starters?" },
          { "name": "How spring-boot-starter-web works" },
          { "name": "Why starters reduce dependency conflicts" }
        ]
      },
      {
        "name": "Configuration Management",
        "subTopics": [
          { "name": "application.properties vs application.yml" },
          { "name": "YAML advantages" },
          { "name": "Profile-specific files" },
          { "name": "Profiles (Dev, QA, Prod)" },
          { "name": "Externalized Configuration - Property priority order (ENV > JVM > config files)" },
          { "name": "How environment variables override config" },
          { "name": "@Value vs @ConfigurationProperties" },
          { "name": "@Value vs @ConfigurationProperties - Differences and When to use which" },
          { "name": "Type safety advantages of @ConfigurationProperties" }
        ]
      },
      {
        "name": "Developer Tools",
        "subTopics": [
          { "name": "Spring Boot DevTools (Live Reload)" },
          { "name": "Lombok integration" }
        ]
      }
    ]
  },
  {
    "id": 2,
    "title": "Auto-Configuration (TOP INTERVIEW AREA)",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Auto-Configuration Internals",
        "subTopics": [
          { "name": "What is auto-configuration?" },
          { "name": "How Spring Boot decides which bean to create" },
          { "name": "@ConditionalOnClass" },
          { "name": "@ConditionalOnMissingBean" },
          { "name": "@ConditionalOnProperty" }
        ]
      },
      {
        "name": "Auto-Configuration Files",
        "subTopics": [
          { "name": "spring.factories (Boot < 3)" },
          { "name": "AutoConfiguration.imports (Boot 3+)" },
          { "name": "How auto-config classes are loaded" }
        ]
      },
      {
        "name": "Disable / Customize Auto-Config",
        "subTopics": [
          { "name": "exclude attribute" },
          { "name": "spring.autoconfigure.exclude" },
          { "name": "Overriding auto-configured beans" }
        ]
      }
    ]
  },
  {
    "id": 3,
    "title": "Spring Boot Startup Lifecycle",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Application Startup",
        "subTopics": [
          { "name": "What happens during SpringApplication.run()" },
          { "name": "Order of execution" },
          { "name": "When beans are created" }
        ]
      },
      {
        "name": "Runners",
        "subTopics": [
          { "name": "CommandLineRunner vs ApplicationRunner" },
          { "name": "Use cases" },
          { "name": "Execution order" }
        ]
      },
      {
        "name": "Embedded Server",
        "subTopics": [
          { "name": "Embedded Tomcat / Jetty / Netty" },
          { "name": "How Boot starts server internally" },
          { "name": "How to change port & server type" }
        ]
      }
    ]
  },
  {
    "id": 4,
    "title": "Data Access & Persistence",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Spring JDBC",
        "subTopics": [
          { "name": "JdbcTemplate & NamedParameterJdbcTemplate" }
        ]
      },
      {
        "name": "Spring Data JPA (Hibernate)",
        "subTopics": [
          { "name": "Why repositories don't need implementation" },
          { "name": "Entity Mapping (@Entity, @Table, @Id, @GeneratedValue)" },
          { "name": "Entity scanning" },
          { "name": "Auto-DDL (ddl-auto)" },
          { "name": "Repositories (CrudRepository, JpaRepository)" },
          { "name": "CrudRepository vs JpaRepository" },
          { "name": "Query Methods (Derived queries, @Query, Native Queries)" },
          { "name": "Derived query method rules" },
          { "name": "Relationships (OneToOne, OneToMany, ManyToMany)" },
          { "name": "Lazy vs Eager loading" },
          { "name": "Pagination & Sorting" },
          { "name": "N+1 Problem - What it is" },
          { "name": "N+1 Problem - How to identify" },
          { "name": "N+1 Problem - Solutions (fetch join, EntityGraph)" }
        ]
      },
      {
        "name": "Transaction Management (INTERVIEW FAVORITE)",
        "subTopics": [
          { "name": "@Transactional - How it works internally" },
          { "name": "Why @Transactional uses AOP" },
          { "name": "Propagation types (REQUIRED, REQUIRES_NEW)" },
          { "name": "Isolation levels" },
          { "name": "Rollback Rules - Checked vs Runtime exception" },
          { "name": "How to force rollback" },
          { "name": "Common Pitfalls - Why @Transactional doesn't work on private methods" },
          { "name": "Common Pitfalls - Why @Transactional doesn't work on internal method calls" },
          { "name": "Proxy limitation explanation" }
        ]
      },
      {
        "name": "NoSQL Integration",
        "subTopics": [
          { "name": "Spring Data MongoDB" },
          { "name": "Spring Data Redis (Caching & Pub/Sub)" }
        ]
      },
      {
        "name": "Database Migration",
        "subTopics": [
          { "name": "Flyway or Liquibase integration" }
        ]
      }
    ]
  },
  {
    "id": 5,
    "title": "Web & REST API Development",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Controllers",
        "subTopics": [
          { "name": "@RestController vs @Controller" },
          { "name": "@RequestMapping vs @GetMapping" },
          { "name": "@PathVariable vs @RequestParam" },
          { "name": "@RequestBody vs @ModelAttribute" }
        ]
      },
      {
        "name": "Response Handling",
        "subTopics": [
          { "name": "ResponseEntity" },
          { "name": "HTTP status codes best practices" }
        ]
      },
      {
        "name": "Exception Handling",
        "subTopics": [
          { "name": "@ExceptionHandler" },
          { "name": "@ControllerAdvice" },
          { "name": "Global vs local exception handling" }
        ]
      },
      {
        "name": "Advanced REST",
        "subTopics": [
          { "name": "Bean Validation (Hibernate Validator, @Valid, @NotNull, @Size)" },
          { "name": "HATEOAS (Hypermedia as the Engine of Application State)" },
          { "name": "Content Negotiation (JSON vs XML)" },
          { "name": "File Upload/Download" }
        ]
      },
      {
        "name": "API Documentation",
        "subTopics": [
          { "name": "OpenAPI 3.0 / Swagger (SpringDoc)" }
        ]
      }
    ]
  },
  {
    "id": 6,
    "title": "Spring Boot Security (HIGH DEMAND)",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Core Concepts",
        "subTopics": [
          { "name": "Authentication vs Authorization" },
          { "name": "Stateless vs Stateful auth" },
          { "name": "SecurityFilterChain" }
        ]
      },
      {
        "name": "JWT with Spring Boot",
        "subTopics": [
          { "name": "Why JWT is stateless" },
          { "name": "Filter flow" },
          { "name": "Where token is validated" }
        ]
      },
      {
        "name": "Method Security",
        "subTopics": [
          { "name": "@PreAuthorize" },
          { "name": "@PostAuthorize" },
          { "name": "Role vs Authority" }
        ]
      },
      {
        "name": "CSRF & CORS",
        "subTopics": [
          { "name": "What CSRF is" },
          { "name": "Why CSRF disabled for REST APIs" },
          { "name": "Browser-side vs server-side CORS" }
        ]
      }
    ]
  },
  {
    "id": 7,
    "title": "Microservices & Spring Cloud",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Service Discovery",
        "subTopics": [
          { "name": "Netflix Eureka / HashiCorp Consul" }
        ]
      },
      {
        "name": "API Gateway",
        "subTopics": [
          { "name": "Spring Cloud Gateway (Routing, Filtering, Rate Limiting)" }
        ]
      },
      {
        "name": "Config Management",
        "subTopics": [
          { "name": "Spring Cloud Config Server (Centralized configuration)" }
        ]
      },
      {
        "name": "Resilience & Fault Tolerance",
        "subTopics": [
          { "name": "Resilience4j (Circuit Breaker, Retry, Rate Limiter, Bulkhead)" }
        ]
      },
      {
        "name": "Distributed Tracing",
        "subTopics": [
          { "name": "Micrometer Tracing (formerly Sleuth) + Zipkin/Brave" }
        ]
      }
    ]
  },
  {
    "id": 8,
    "title": "Spring AI (Generative AI)",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Introduction to Generative AI",
        "subTopics": [
          { "name": "Large Language Models (LLMs) concepts" }
        ]
      },
      {
        "name": "Spring AI Core",
        "subTopics": [
          { "name": "Chat Client API: Interacting with OpenAI, Azure OpenAI, Ollama, HuggingFace" },
          { "name": "Prompts: Prompt Templates, Prompt Engineering within Java" },
          { "name": "Output Parsers: Converting AI text responses into Java Objects (POJOs)" }
        ]
      },
      {
        "name": "Embeddings & Vector Databases",
        "subTopics": [
          { "name": "Text Embeddings models" },
          { "name": "Vector Store integration (PGVector, Pinecone, Milvus, Redis)" }
        ]
      },
      {
        "name": "RAG (Retrieval Augmented Generation)",
        "subTopics": [
          { "name": "Document Readers (PDF, Text, JSON)" },
          { "name": "Token Splitters" },
          { "name": "Contextual search implementation" }
        ]
      },
      {
        "name": "Advanced AI",
        "subTopics": [
          { "name": "Function Calling (Letting AI call your Java methods)" },
          { "name": "Image Generation (DALL-E, Stability AI)" }
        ]
      }
    ]
  },
  {
    "id": 9,
    "title": "Messaging & Event-Driven Architecture",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "JMS (Java Message Service)",
        "subTopics": [
          { "name": "ActiveMQ integration" }
        ]
      },
      {
        "name": "Apache Kafka",
        "subTopics": [
          { "name": "Spring for Apache Kafka" },
          { "name": "Producers, Consumers, Consumer Groups" }
        ]
      },
      {
        "name": "RabbitMQ",
        "subTopics": [
          { "name": "Exchanges, Queues, Routing Keys" }
        ]
      },
      {
        "name": "Spring Cloud Stream",
        "subTopics": [
          { "name": "Binder abstraction (Switch between Kafka/RabbitMQ easily)" }
        ]
      }
    ]
  },
  {
    "id": 10,
    "title": "Spring Batch & Scheduling",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Scheduling",
        "subTopics": [
          { "name": "@Scheduled (FixedRate, FixedDelay, Cron expressions)" },
          { "name": "Quartz Scheduler integration" }
        ]
      },
      {
        "name": "Spring Batch",
        "subTopics": [
          { "name": "Job, Step, JobRepository" },
          { "name": "ItemReader, ItemProcessor, ItemWriter" },
          { "name": "Chunk-oriented processing" },
          { "name": "Error handling (Skip, Retry policies)" },
          { "name": "Parallel processing & Partitioning" }
        ]
      }
    ]
  },
  {
    "id": 11,
    "title": "Reactive Programming (WebFlux)",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Project Reactor",
        "subTopics": [
          { "name": "Mono vs Flux" },
          { "name": "Backpressure" }
        ]
      },
      {
        "name": "Spring WebFlux",
        "subTopics": [
          { "name": "Non-blocking REST APIs" },
          { "name": "Netty Server" },
          { "name": "Reactive Database Access (R2DBC)" }
        ]
      }
    ]
  },
  {
    "id": 12,
    "title": "Spring Boot Testing",
    "difficulty": "intermediate",
    "topics": [
      {
        "name": "Testing Types",
        "subTopics": [
          { "name": "Unit vs Integration testing" }
        ]
      },
      {
        "name": "Unit Testing",
        "subTopics": [
          { "name": "JUnit 5 & Mockito (Mocking dependencies)" }
        ]
      },
      {
        "name": "Integration Testing",
        "subTopics": [
          { "name": "@SpringBootTest" },
          { "name": "Test Slices (@WebMvcTest, @DataJpaTest)" }
        ]
      },
      {
        "name": "Mocking",
        "subTopics": [
          { "name": "Mockito basics" },
          { "name": "MockBean vs SpyBean" }
        ]
      },
      {
        "name": "Advanced Testing",
        "subTopics": [
          { "name": "Testcontainers (Spinning up real DBs/Kafka in Docker for tests)" },
          { "name": "WireMock (Mocking external APIs)" }
        ]
      }
    ]
  },
  {
    "id": 13,
    "title": "Observability & Production Ready (Actuator)",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Spring Boot Actuator",
        "subTopics": [
          { "name": "Important endpoints: /health, /metrics, /info" },
          { "name": "Custom health indicators" }
        ]
      },
      {
        "name": "Monitoring",
        "subTopics": [
          { "name": "Micrometer basics" },
          { "name": "Prometheus & Grafana overview" }
        ]
      },
      {
        "name": "Logging",
        "subTopics": [
          { "name": "SLF4J, Logback" },
          { "name": "Log aggregation (ELK Stack: Elasticsearch, Logstash, Kibana)" }
        ]
      },
      {
        "name": "Deployment",
        "subTopics": [
          { "name": "Dockerizing Spring Boot" },
          { "name": "Why Boot apps are container-friendly" },
          { "name": "Fat JAR vs Thin JAR" }
        ]
      }
    ]
  },
  {
    "id": 14,
    "title": "Performance & Real-World Scenarios (Senior Level)",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "Startup & Memory",
        "subTopics": [
          { "name": "Why Spring Boot apps are heavy" },
          { "name": "Reduce startup time" },
          { "name": "GraalVM Native Image (concept)" },
          { "name": "GraalVM Native Images (AOT Compilation for instant startup)" }
        ]
      },
      {
        "name": "Common Production Issues",
        "subTopics": [
          { "name": "Bean overriding issues" },
          { "name": "Circular dependencies" },
          { "name": "Configuration mismatch across environments" }
        ]
      }
    ]
  },
  {
    "id": 15,
    "title": "Miscellaneous / Advanced Spring",
    "difficulty": "advanced",
    "topics": [
      {
        "name": "GraphQL",
        "subTopics": [
          { "name": "Spring for GraphQL (Controller, Schema, DataFetchers)" }
        ]
      },
      {
        "name": "WebSockets",
        "subTopics": [
          { "name": "STOMP protocol, SockJS, Real-time chat" }
        ]
      },
      {
        "name": "Caching",
        "subTopics": [
          { "name": "@Cacheable, @CacheEvict" },
          { "name": "Providers: Caffeine, Redis" }
        ]
      }
    ]
  }
]
